import { BatchResult, AnalysisResult } from '../types/analysis';

export class ReportGenerator {
  generate(batchResult: BatchResult): string {
    const { results, summary, duration } = batchResult;
    
    return `# ENS Hackathon Analysis Report

**Generated:** ${new Date().toISOString()}  
**Duration:** ${duration.toFixed(1)} seconds  
**Projects Analyzed:** ${results.length}/${batchResult.total}  
**Success Rate:** ${Math.round((results.length / batchResult.total) * 100)}%

## Executive Summary

- **ENS Projects Found:** ${summary.ensProjects} out of ${results.length} (${summary.ensPercentage}%)
- **Average Integration Quality:** ${summary.averageRating.toFixed(1)}/5 ⭐
- **Top Integration:** ${summary.topProject?.repository || 'None'} ${summary.topProject ? `(${summary.topProject.summary})` : ''}

## Quality Distribution

\`\`\`
${this.generateRatingChart(summary.ratingDistribution)}
\`\`\`

## Integration Type Breakdown

| Type | Count | % of ENS Projects |
|------|-------|-------------------|
${Object.entries(summary.integrationTypeBreakdown)
  .sort(([,a], [,b]) => b - a)
  .map(([type, count]) => `| ${type.replace('_', ' ')} | ${count} | ${Math.round((count / summary.ensProjects) * 100)}% |`)
  .join('\n')}

## Most Popular Libraries

| Library | Usage | % of ENS Projects |
|---------|-------|-------------------|
${summary.mostCommonLibraries
  .map(lib => `| ${lib.name} | ${lib.count} | ${lib.percentage}% |`)
  .join('\n')}

---

${this.generateProjectSections(results)}

---

## Technical Insights

### Innovation Patterns Detected:
${this.generateInsights(results)}

### Quality Indicators:
- Projects with **custom resolvers**: ${this.getAverageRating(results, 'custom_resolver').toFixed(1)}⭐ average
- Projects with **AI integration**: ${this.getAverageRating(results, 'ai_integration').toFixed(1)}⭐ average
- Projects with **official libraries**: ${this.getAverageRating(results, 'official').toFixed(1)}⭐ average

---

*Report generated by ENS Hackathon Analyzer v1.0.0*  
*Analysis completed in ${duration.toFixed(1)} seconds | ${results.length} repositories processed*
`;
  }

  private generateRatingChart(ratingDistribution: Record<number, number>): string {
    const maxCount = Math.max(...Object.values(ratingDistribution));
    const chart: string[] = [];
    
    for (let rating = 5; rating >= 0; rating--) {
      const count = ratingDistribution[rating] || 0;
      const percentage = count > 0 ? Math.round((count / maxCount) * 100) : 0;
      const stars = '⭐'.repeat(rating) || '❌';
      const label = rating === 0 ? 'No ENS' : `${rating} star${rating > 1 ? 's' : ''}`;
      const bar = '█'.repeat(Math.floor(percentage / 3));
      
      chart.push(`${stars.padEnd(10)} ${label.padEnd(12)}: ${count.toString().padStart(2)} projects ${bar}`);
    }
    
    return chart.join('\n');
  }

  private generateProjectSections(results: AnalysisResult[]): string {
    const sections: string[] = [];
    
    // Group by rating
    for (let rating = 5; rating >= 1; rating--) {
      const projectsAtRating = results.filter(r => r.rating === rating);
      if (projectsAtRating.length === 0) continue;
      
      const ratingLabels = {
        5: '⭐⭐⭐⭐⭐ Exceptional Integrations',
        4: '⭐⭐⭐⭐ Prize-worthy Integrations', 
        3: '⭐⭐⭐ Excellent Integrations',
        2: '⭐⭐ Good Integrations',
        1: '⭐ Basic Integrations'
      };
      
      sections.push(`## ${ratingLabels[rating as keyof typeof ratingLabels]} (${projectsAtRating.length} projects)`);
      sections.push('');
      
      projectsAtRating.forEach((project, index) => {
        sections.push(`### ${index + 1}. ${project.repository} - ${project.rating}⭐`);
        sections.push(`- **Repository:** ${project.url}`);
        sections.push(`- **Integration Types:** ${project.integrationTypes.join(', ')}`);
        sections.push(`- **Summary:** ${project.summary}`);
        
        if (project.evidence.length > 0) {
          const keyEvidence = project.evidence.slice(0, 3);
          sections.push(`- **Key Evidence:** ${keyEvidence.map(e => e.pattern).join(', ')}`);
        }
        
        sections.push('');
      });
    }
    
    // Non-ENS projects
    const nonENSProjects = results.filter(r => r.rating === 0);
    if (nonENSProjects.length > 0) {
      sections.push(`## ❌ Non-ENS Projects (${nonENSProjects.length} projects)`);
      sections.push('');
      nonENSProjects.forEach(project => {
        sections.push(`- **${project.repository}** - ${project.summary}`);
      });
    }
    
    return sections.join('\n');
  }

  private generateInsights(results: AnalysisResult[]): string {
    const ensResults = results.filter(r => r.hasENS);
    const insights: string[] = [];
    
    // AI integration trend
    const aiProjects = ensResults.filter(r => 
      r.integrationTypes.includes('ai_integration' as any)
    );
    if (aiProjects.length > 0) {
      insights.push(`1. **AI + ENS Integration** (${Math.round((aiProjects.length / ensResults.length) * 100)}% of projects) - Emerging trend`);
    }
    
    // Custom resolvers
    const customResolverProjects = ensResults.filter(r => 
      r.evidence.some(e => e.integrationType === 'custom_resolver')
    );
    if (customResolverProjects.length > 0) {
      insights.push(`2. **Custom CCIP-Read Resolvers** (${Math.round((customResolverProjects.length / ensResults.length) * 100)}% of projects) - Advanced pattern`);
    }
    
    // L2 integration
    const l2Projects = ensResults.filter(r => 
      r.evidence.some(e => e.integrationType === 'l2_subdomain')
    );
    if (l2Projects.length > 0) {
      insights.push(`3. **L2-Native Implementations** (${Math.round((l2Projects.length / ensResults.length) * 100)}% of projects) - Future-focused`);
    }
    
    return insights.join('\n');
  }

  private getAverageRating(results: AnalysisResult[], type: string): number {
    let filteredResults: AnalysisResult[];
    
    if (type === 'custom_resolver') {
      filteredResults = results.filter(r => 
        r.evidence.some(e => e.integrationType === 'custom_resolver')
      );
    } else if (type === 'ai_integration') {
      filteredResults = results.filter(r => 
        r.integrationTypes.includes('ai_integration' as any)
      );
    } else if (type === 'official') {
      filteredResults = results.filter(r => 
        r.evidence.some(e => 
          e.type === 'dependency' && 
          ['@ensdomains/ensjs', '@ensdomains/thorin', '@ensdomains/durin'].includes(e.pattern)
        )
      );
    } else {
      filteredResults = results;
    }
    
    if (filteredResults.length === 0) return 0;
    
    const totalRating = filteredResults.reduce((sum, r) => sum + r.rating, 0);
    return totalRating / filteredResults.length;
  }
}